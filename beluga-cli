#!/usr/bin/env bash

# beluga-cli
versionnumber="v0.2.0"
# exit codes:
#  0 success
#  1 failure: operation aborted
#  2 invalidation request already pending
#  3 illegal input
#  4 missing config
#  5 partial failure

#beluga_api [ --token-id=<id> --token-secret=<secret> ] [ --user=<user> --password=<pass> ] --request-method=<method> --request-path=<path> [ --request-body=<body> ]
beluga_api ( ) {
  IFS=$' '

  for item in "$@"; do
    if [[ ${item:0:11} == "--token-id=" ]]; then
      tokenid=${item##*=}
    elif [[ ${item:0:15} == "--token-secret=" ]]; then
      tokensecret=${item##*=}
    elif [[ ${item:0:7} == "--user=" ]]; then
      buser=${item##*=}
    elif [[ ${item:0:11} == "--password=" ]]; then
      bpassword=${item#--password=}
    elif [[ ${item:0:17} == "--request-method=" ]]; then
      requestmethod=${item##*=}
    elif [[ ${item:0:15} == "--request-path=" ]]; then
      requestpath=${item##*=}
    elif [[ ${item:0:15} == "--request-body=" ]]; then
      requestbody=${item##*=}
    fi
  done

  # list sites:
  # requestpath='/api/cdn/v2/sites'
  # requestmethod='GET'

  # invalidation:
  # beluga_api --token-id= --token-secret= --request-method=POST --request-path=/api/cdn/v2/invalidations --request-body="{\"urls\":[{\"url\":\"$myurl\"}], \"limit-records\": \"50000\"}"
  # requestmethod='POST'
  # requestpath='/api/cdn/v2/invalidations'
  # requestbody="{\"urls\":[{\"url\":\"$myurl\"}], \"limit-records\": \"50000\"}"

  requesturlbase='https://api.belugacdn.com'

  isodate=$(gdate -u "+%Y-%m-%dT%H:%M:%S.%6NZ" 2> /dev/null)
  if [[ $? -eq 127 ]]; then
    isodate=$(date -u "+%Y-%m-%dT%H:%M:%S.%6NZ")
  fi

  # TOKEN AUTHENTICATION (MUCH BETTER... BUT I CAN'T GET IT WORKING)
  signstring="$requestmethod:$requestpath:$isodate"

  if [[ ( $requestmethod == 'POST' || $requestmethod == 'PUT' ) && ! -z $requestbody ]]; then
    bodyhash=$(echo -n $requestbody | openssl sha512)
    signstring="$signstring:$bodyhash"
  fi

  if [[ ! ( -z $tokenid || -z $tokensecret) ]]; then
    signhmac=$(echo -n "$signstring" | openssl sha512 -hmac "$tokensecret")
    authheader="Token $tokenid $signhmac"
  elif [[ ! ( -z "$buser" || -z "$bpassword" ) ]]; then
    authheader="Basic $(echo -n "$buser:$bpassword" | openssl base64)"
  fi
  #echo $signstring

  if [[ ! -z $requestbody ]]; then
    curl -kH "Content-type: application/json" \
         -H "Accept: application/json" \
         -H "Date: $isodate" \
         -H "Authorization: $authheader" \
         -d "$requestbody" "$requesturlbase$requestpath" 2> /dev/null
    return $?
  else
    curl -kH "Accept: application/json" \
         -H "Date: $isodate" \
         -H "Authorization: $authheader" \
         "$requesturlbase$requestpath" 2> /dev/null
    return $?
  fi
}

# usage: display_message <message>
# attempts to constrain status messages to fit the current terminal size, by
# replacing certain substrings with shorter aliases, etc
display_message ( ) {
  if [[ ! $inputflags =~ 's' ]]; then
    IFS=$'\n'
    local line
    for line in $1; do
      if [[ `echo -e $line | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}'` -gt $(tput cols) ]]; then
        if [[ $line != ${line//$HOME/\~} ]]; then
          line=${line//$HOME/\~}
        fi

        if [[ `echo -e $line | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}'` -gt $(tput cols) ]]; then
          if [[ $line =~ "http://$cdnurl" ]]; then
            line=${line//http:\/\/$cdnurl/cdn:/}
          fi
        fi

        while [[ `echo -e $line | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}'` -gt $(tput cols) ]]; do
          local shortl=''
          IFS=' '
          for part in $line; do
            if [[ `echo $part | tr -dc '/' | awk '{print length}'` -gt 0 ]]; then
              if [[ ${part:0:6} == 'cdn://' ]]; then
                part=${part#cdn:\/\/}
                part=${part#\.\.\.}
                shortl+="cdn://...${part#*?\/} "
              else
                shortl+="...${part#*?\/} "
              fi
            else
              shortl+="$part "
            fi
          done

          if [[ "$line" == "$(echo $shortl | awk '{$1=$1};1')" ]]; then
            break
          else
            line=$(echo $shortl | awk '{$1=$1};1')
          fi
        done
      fi
      word_wrap $(tput cols) 0 "$line"
    done
  fi
}

# usage: validate_curl_result <result>
# interprets certain relevant curl exit codes
#
# exit codes:
#  0 success
#  1 failure
validate_curl_result ( ) {
  local res=$1

  if [[ ! $res -eq 0 ]]; then
    local msg
    if [[ $res -eq 78 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: file not found]"
    elif [[ $res -eq 6 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: couldn't resolve host]"
    elif [[ $res -eq 7 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: failed to connect]"
    elif [[ $res -eq 9 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: ftp access denied]"
    elif [[ $res -eq 19 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: couldn't access file]"
    elif [[ $res -eq 21 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: QUOT cmd failed]"
    elif [[ $res -eq 78 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res: remote file does not exist]"
    else
      msg="\033[31;1mfailed:\033[0m operation not completed [error $res]"
    fi
    echo -e "$msg"
    return 1
  else
    echo -e "\033[1;92mdone\033[0m"
    return 0
  fi
}

# usage: center_text <text>
# centers text in terminal window
center_text ( ) {
  IFS=$'\n'
  left_pad=$(expr $(expr $(tput cols) - $(echo -e $1 | tr -d '\n' | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}')) / 2)
  tab=''
  if [[ $left_pad -gt 0 ]]; then
    for n in $(seq 0 $left_pad); do
      tab+=$' '
    done
  fi

  echo -e "$tab$1"
}

# usage: word_wrap <maxlinelength> [a- or <numuntabbedlines>- or
# <numinitiallines>:<initiallefttab>-]<lefttab> <text>
#
# arguments:
#  maxlinelength: max length of each line, including initial tab
#  numuntabbedlines: number of initial lines with no tab. can also be set to
#                    the letter 'a' for 'append mode' (to add to an existing
#                    line)
#  numinitiallines: num. of initial lines w/ tab of length 'initiallefttab'
#  initiallefttab: length of tab for 'numinitiallines' initial lines
#  lefttab: length of tab after 'numinitiallines' or 'numuntabbedlins', or,
#           if used alone, tab length for entire paragraph.
#  text: text to be displayed with word wrap
#
# for example, `word_wrap 30 1:4-8 $msg` would print $msg in the following
# format, where no line is longer than 30 characters total, the first line
# has a 4 space left tab, the following lines have an 8 space tab, and "word
# wrap" is enabled (initial 'tab' spaces represented by periods for clarity):
#  ....Lorem ipsum dolor sit amet
#  ........consectetur adipiscing
#  ........elit. Maecenas
#  ........convallis, leo non
#  ........sollicitudin molestie.
#
# it should work fine with all ANSI color codes.
word_wrap ( ) {
  if [[ ! $inputflags =~ 's' ]]; then
    IFS=$' '
    maxlength=$1

    if [[ $2 =~ '-' ]]; then
      tab=$(echo $2 | cut -d'-' -f2 )
      start=$(echo $2 | cut -d'-' -f1 )
      starttab=0
      if [[ $start == 'a' ]]; then
        start=1
        mode='append'
      elif [[ $start =~ ':' ]]; then
        start=$(echo $2 | cut -d'-' -f1 | cut -d':' -f1)
        starttab=$(echo $2 | cut -d'-' -f1 | cut -d':' -f2)
      fi
    else
      tab=$2
      start=0
    fi

    curritems=( $(echo -e $@) )
    currline=${curritems[2]}

    linenum=1
    for word in ${curritems[@]:3}; do
      if [[ $linenum -gt $start ]] || [[ $mode == 'append' ]]; then
        max=$(expr $maxlength - $tab)
      else
        max=$(expr $maxlength - $starttab)
      fi

      if [[ $(echo "$currline $word" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}') -lt $max ]]; then
        currline="$currline $word"
      else
        if [[ $linenum -gt $start ]]; then
          for ((n=0;n<$tab;n++)); do
            echo -n ' '
          done
        else
          for ((n=0;n<$starttab;n++)); do
            echo -n ' '
          done
        fi
        echo -e $currline
        currline=$word
        let linenum++
      fi
    done

    if [[ $linenum -gt $start ]]; then
      for ((n=0;n<$tab;n++)); do
        echo -n ' '
      done
    else
      for ((n=0;n<$starttab;n++)); do
        echo -n ' '
      done
    fi
    echo $currline
  fi
}

# usage: display_help_page (or can be piped through less for manpage-like
# behavior)
# displays extended help page for beluga-cli
display_help_page ( ) {
  echo
  echo
  center_text "\033[1mextended help for beluga-cli $versionnumber\033[0m"
  echo
  echo -e "\n \033[1;4musage\033[0;1m:\033[0m \033[37mbeluga-cli\033[0m <\033[37mcommand\033[0m> [\033[37mflags\033[0m] [\033[37marguments\033[0m]\n"
  echo -e " \033[1;4mdescription\033[0;1m:\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "beluga-cli is a bash utility which uses \033[4mcurl(1)\033[0m - with the exception of the ftp command, which uses \033[4mftp(1)\033[0m - to efficiently manipulate files on an ftp origin server (like the one provided by beluga) and interact with the belugacdn api (\033[4mhttp://www.belugacdn.com/\033[0m). it can be used to quickly and easily accomplish, and/or as a step in the automation of, many tasks involving the management of objects which fit one or both these criteria."
  echo -e "\n \033[1;4mpossible commands\033[0;1m:\033[0m"
  echo
  center_text "\033[1mfile manipulation\033[0m\n"
  echo -en "     \033[1mcp\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "copy a file to, from, or within the origin, resulting in duplicate copies at the origin and destination."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37mcp \033[0m[\033[37m-is\033[0m] <\033[37mlocalpath\033[0m> <\033[37mcdn://uri\033[0m> or <\033[37mcdn://uri\033[0m> <\033[37mlocalpath\033[0m> or <\033[37mcdn://uri\033[0m> <\033[37mcdn://uri\033[0m>"
  echo
  echo -en "     \033[1mmv\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "move a file to, from, or within the server, so that the original copy is deleted and only the new one at the destination is kept."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37mmv \033[0m[\033[37m-is\033[0m] <\033[37mlocalpath\033[0m> <\033[37mcdn://uri\033[0m> or <\033[37mcdn://uri\033[0m> <\033[37mlocalpath\033[0m> or <\033[37mcdn://uri\033[0m> <\033[37mcdn://uri\033[0m>"
  echo
  echo -e "     \033[1mrm\033[0m     delete a remote file or directory."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37mrm \033[0m[\033[37m-irs\033[0m] <\033[37mcdn://uri\033[0m>"
  echo
  echo
  center_text "\033[1mnavigation/file discovery\033[0m"
  echo
  echo -ne "     \033[1mftp\033[0m    "
  word_wrap $(expr $(tput cols) - 5) a-12 "log on to the origin server in an interactive ftp session."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37mftp\033[0m"
  echo
  echo  -e "     \033[1mls\033[0m     briefly list the contents of a directory."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37mls\033[0m <\033[37mcdn://uri\033[0m>"
  echo
  echo -ne "     \033[1mll\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "list the contents of a directory plus permissions, creation date, etc."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37mll\033[0m <\033[37mcdn://uri\033[0m>"
  echo
  echo
  center_text "\033[1mcdn utilities\033[0m\n"
  echo -en "     \033[1miv\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "invalidate a file in the cdn's cache, so that another copy must be retrieved from the origin server."
  word_wrap $(expr $(tput cols) - 5) 1:12-19 "usage: \033[37mbeluga-cli \033[37miv\033[0m \033[0m[\033[37m-s\033[0m] <\033[37mcdn://uri\033[0m>"
  echo
  echo -e "\n \033[1;4mpossible flags\033[0;1m:\033[0m"
  echo
  echo -en "     \033[1m-i\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "if a remote file may be modified by the specified command, beluga-cli will request invalidation of that uri after the operation is complete."
  echo
  echo -en "     \033[1m-r\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "delete all contents of the specified directory recursively."
  echo
  echo -en "     \033[1m-s\033[0m     "
  word_wrap $(expr $(tput cols) - 5) a-12 "the program will run silently."
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "each flag can only be used on certain commands. if a flag is used on a command where it is not standard, beluga-cli will generally print an error message but then ignore the flag and continue."
  echo
  echo -e " \033[1;4mbrief examples\033[0;1m:\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "the following examples should help to demonstrate what normal input and output look like, as well as suggest some common applications which might be useful."
  echo
  word_wrap $(expr $(tput cols) - 5) 1:5-8 "1. invalidate a remote uri so that it is deleted from the belugacdn cache and must be retrieved again from the origin:"
  echo
  word_wrap $(expr $(tput cols) - 5) 8 "\$ \033[37mbeluga-cli \033[37miv \033[37mcdn://public/main.html\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92minvalidating:\033[0m http://cdn.example.com/public/main.html"
  word_wrap $(expr $(tput cols) - 5) 8 "request \033[1;92mpending\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 1:5-8 "2. replace an online file with an updated local copy, then request invalidation so the update becomes visible on the cdn:"
  echo
  word_wrap $(expr $(tput cols) - 5) 8 "\$ \033[37mbeluga-cli \033[37mcp \033[37m-i \033[37mwork/progressreport.pdf \033[37mcdn://reports/2018.pdf\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92muploading:\033[0m work/progressreport.pdf -> cdn://reports/2018.pdf"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdone\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92minvalidating:\033[0m http://cdn.example.com/reports/2018.pdf"
  word_wrap $(expr $(tput cols) - 5) 8 "request \033[1;92mpending\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 1:5-8 "3. look through the contents of a directory and download a particular file:"
  echo
  word_wrap $(expr $(tput cols) - 5) 8 "\$ \033[37mbeluga-cli \033[37mls \033[37mcdn://images/\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mlisting \033[1mcontents \033[1mof\033[0m cdn://images/"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92msuccess:\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "edited"
  word_wrap $(expr $(tput cols) - 5) 8 "babypic.jpg"
  word_wrap $(expr $(tput cols) - 5) 8 "logo.png"
  word_wrap $(expr $(tput cols) - 5) 8 "product.jpeg"
  word_wrap $(expr $(tput cols) - 5) 8 "product_rev3.jpeg"
  word_wrap $(expr $(tput cols) - 5) 8 "\$ \033[37mbeluga-cli \033[37mcp \033[37mcdn://images/logo.png \033[37m~/Downloads\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdownloading:\033[0m cdn://images/logo.png -> ~/Downloads/logo.png"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdone\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 1:5-8 "4. use grep and xargs to download every image file (.png or .jpg) in the dir from the previous example to a local directory named 'cdnimg', with 'cp_' prepended to each local filename:"
  echo
  word_wrap $(expr $(tput cols) - 5) 8 "\$ \033[37mbeluga-cli \033[37mls \033[37mcdn://images \033[37m 2> /dev/null | \033[37mgrep \033[37m-E \033[37m\"\\.(jpe?g|png)\" \033[37m| \033[37mxargs \033[37m-I \033[37m% \033[37mbeluga-cli \033[37mcp \033[37mcdn://images/% \033[37m~/cdnimg/cp_%\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdownloading:\033[0m cdn://images/babypic.jpg -> ~/cdnimg/cp_babypic.jpg"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdone\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdownloading:\033[0m cdn://images/logo.png -> ~/cdnimg/cp_logo.png"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdone\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdownloading:\033[0m cdn://images/product.jpeg -> ~/cdnimg/cp_product.jpeg"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdone\033[0m"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdownloading:\033[0m cdn://images/product_rev3.jpeg -> ~/cdnimg/cp_product_rev3.jpeg"
  word_wrap $(expr $(tput cols) - 5) 8 "\033[1;92mdone\033[0m"
  echo
  echo -e " \033[1;4msetup\033[0;1m:\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "in order to get everything working correctly before you start using beluga-cli, you must run the command \033[37mbeluga-cli setup\033[0m to define the location and credentials used for your origin, the credentials used for belugacdn, and so on."
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "\033[1mcaution:\033[0m your origin server username and password will be stored & transmitted as plain text, so ensure they are not used elsewhere."
  echo
  echo -e " \033[1;4mtips & tricks\033[0;1m:\033[0m"
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "\033[1mhelp:\033[0m you can include the word \033[37;1mhelp\033[0m after any command for a quick refresher about the use of that particular command, or by itself (\033[37mbeluga-cli \033[37mhelp\033[0m) to get this page."
  echo
  if [[ -z $cdnurl ]]; then
    word_wrap $(expr $(tput cols) - 5) 5 "\033[1msetup:\033[0m the \"origin server location\" in \033[37mbeluga-cli \033[37msetup\033[0m should include the entire path used as the origin on belugacdn. if you entered an additional path in your property's settings page on beluga, include it here. if you use beluga's origin solution, this may also include a directory with your property name (e.g. X.X.X.X/cdn.your.site/)"
    echo
    word_wrap $(expr $(tput cols) - 5) 5 "\033[1mremote uri formatting:\033[0m note that in all commands, remote uris should be be formatted as cdn://path. for instance, in order to download the file http://cdn.your.site/dir1/file.txt, you could run the command \033[37mbeluga-cli \033[37mcp \033[37mcdn://dir1/file.txt \033[37m~/file.txt\033[0m. as a general rule, cdn://path/to/obj corresponds to http://cdn.your.site/path/to/obj."
  else
    word_wrap $(expr $(tput cols) - 5) 5 "\033[1msetup:\033[0m the \"origin server location\" in \033[37mbeluga-cli \033[37msetup\033[0m should include the entire path used as the origin on belugacdn. if you entered an additional path in your property's settings page on beluga, include it here. if you use beluga's origin solution, this may also include a directory with your property name (e.g. X.X.X.X/$cdnurl/)"
    echo
    word_wrap $(expr $(tput cols) - 5) 5 "\033[1mremote uri formatting:\033[0m note that in all commands, remote uris should be formatted as cdn://path. for instance, in order to download the file http://$cdnurl/dir1/file.txt, you could run the command \033[37mbeluga-cli \033[37mcp \033[37mcdn://dir1/file.txt \033[37m~/file.txt\033[0m. as a general rule, cdn://path/to/obj corresponds to http://$cdnurl/path/to/obj."
  fi
  echo
  word_wrap $(expr $(tput cols) - 5) 5 "\033[1morigin vs cdn:\033[0m when making changes to files on the origin server, note that the differences may not propagate to the cdn (and therefore become public) until you invalidate the existing uri of the modified file. this includes any operation on a uri that has already been used before: uploading a file to a new uri doesn't require invalidation, but deleting an existing one does."
  echo
  echo
}

# usage: invalidate <path>
# sends an invalidation request to beluga via their api and displays the result
#
# exit codes:
#  0  success
#  1  failure
#  2  uri invalidation already pending
#
# currently uses basic authentication because I can't get token authentication
# working... still working on it.
invalidate ( ) {
  local myurl=http://$cdnurl/$1

  msg="\033[1;92minvalidating:\033[0m $myurl"
  display_message "$msg" >&2

  resp=$(beluga_api --token-id=$defaulttokenid --token-secret=$defaulttokensecret --request-method=POST --request-path=/api/cdn/v2/invalidations --request-body="{\"urls\":[{\"url\":\"$myurl\"}], \"limit-records\": \"50000\"}")
  result=$?

  if [[ $resp =~ "password mismatch" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [user/password incorrect]"
    exitstatus=1
  elif [[ $resp =~ "token lookup failed" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [token id lookup failed]"
    exitstatus=1
  elif [[ $resp =~ "token validation failed" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [token validation failed]"
    exitstatus=1
  else
    curlstatus=$(echo $resp | cut -d',' -f3 | tr -d '"' | cut -d':' -f2)

    validationresult=$(validate_curl_result $result)
    exitstatus=$?
  fi

  if [[ $exitstatus -eq 0 ]]; then
    if [[ $curlstatus == "pending" ]]; then
      word_wrap $(tput cols) 0 "request \033[1;92mpending\033[0m" >&2
      return 0
    elif [[ $curlstatus == "previously-pending" ]]; then
      word_wrap $(tput cols) 0 "request \033[1;33mpreviously pending\033[0m" >&2
      return 2
    elif [[ $curlstatus == "failure" ]]; then
      word_wrap $(tput cols) 0 "request \033[1;91mfailed\033[0m" >&2
      return 1
    else
      word_wrap $(tput cols) 0 "request $curlstatus" >&2
      return $exitstatus
    fi
  else
    word_wrap $(tput cols) 0 "$validationresult" >&2
    return $exitstatus
  fi
}

# usage: recursive_delete <path>
#
# exit codes:
#  0 success
#  1 total failure
#  5 partial failure
recursive_delete ( ) {
  local path=$1
  local totalnum=0
  local failnum=0

  filelist=$(curl -l "ftp://$serverdefault/$path/" 2> /dev/null)
  local lresult=$?

  IFS=$'\n'
  if [[ $lresult -eq 0 ]]; then
    for item in $filelist; do
      recursive_delete "$path/$item"
    done
    curl -l "ftp://$serverdefault/" -Q "-RMD $path" > /dev/null 2> /dev/null
    lresult=$?
    let totalnum++

    if [[ $lresult -ne 0 ]]; then
      display_message "\033[31;1merror\033[0m deleting cdn://$path/" >&2
      let failnum++
    fi
  else
    curl -l "ftp://$serverdefault/" -Q "-DELE $path" > /dev/null 2> /dev/null
    lresult=$?
    let totalnum++

    if [[ $lresult -ne 0 ]]; then
      display_message "\033[31;1merror\033[0m deleting cdn://$path" >&2
      let failnum++
    elif [[ $inputflags =~ 'i' ]]; then
      invalidate $path
    fi
  fi

  if [[ $failnum -eq $totalnum ]]; then
    return 1
  elif [[ $failnum -gt 0 ]]; then
    return 5
  else
    return 0
  fi
}

if [[ -e "$HOME/Library/beluga-cli/.defaults" ]]; then
  defaults=( $(cat $HOME/Library/beluga-cli/.defaults) )
  if [[ $(echo -ne "${defaults[0]}\n${defaults[1]}\n${defaults[2]}" | md5) != $(echo ${defaults[3]} | cut -d':' -f2) ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1merror:\033[0m config file checksum invalid" >&2
    word_wrap $(expr $(tput cols) - 1) 1 "run \033[1mbeluga-cli setup\033[0m to set up a new defaults file, or \033[1mbeluga-cli \033[1mhelp\033[0m for more information." >&2
    exit 4
  else
    serverdefault=${defaults[0]}
    if [[ ${serverdefault:$(expr ${#serverdefault} - 1)} == '/' ]]; then
      serverdefault=${serverdefault:0:$(expr ${#serverdefault} - 1)}
    fi
    apiauthkey=${defaults[1]}
    cdnurl=${defaults[2]}
    if [[ ${cdnurl:$(expr ${#cdnurl} - 1)} == '/' ]]; then
      cdnurl=${cdnurl:0:$(expr ${#cdnurl} - 1)}
    fi
    if [[ ${cdnurl:0:7} == 'http://' ]]; then
      cdnurl=${cdnurl:7}
    elif [[ ${cdnurl:0:8} == 'https://' ]]; then
      cdnurl=${cdnurl:8}
    fi
  fi
fi
if [[ $1 != "help" && $1 != "setup" ]]; then
  if [[ ! -d "$HOME/Library/beluga-cli" ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1merror:\033[0m missing config directory ~/Library/beluga-cli. run \033[1mbeluga-cli setup\033[0m to configure defaults, or \033[1mbeluga-cli \033[1mhelp\033[0m for more information." >&2
    exit 4
  elif [[ ! -e "$HOME/Library/beluga-cli/.defaults" ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1merror:\033[0m missing config file ~/Library/beluga-cli/.defaults. run \033[1mbeluga-cli setup\033[0m to configure defaults, or \033[1mbeluga-cli \033[1mhelp\033[0m for more information." >&2
    exit 4
  fi
elif [[ $1 == "setup" ]]; then
  if [[ ! -d "$HOME/Library/beluga-cli" ]]; then
    mkdir "$HOME/Library/beluga-cli"
  fi
  if [[ ! -e "$HOME/Library/beluga-cli/.defaults" ]]; then
    touch "$HOME/Library/beluga-cli/.defaults"
    chmod +rw-x "$HOME/Library/beluga-cli/.defaults"
  fi
  echo
  word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1mcaution:\033[0m your origin server username and password will be stored and transmitted as plain text, so ensure they are not used elsewhere." >&2
  word_wrap $(expr $(tput cols) - 1) 1 "run \033[1mbeluga-cli \033[1mhelp\033[0m and see the section 'setup' for more information on what to enter here." >&2
  echo
  read -p " origin server location: " serverlocation </dev/tty
  read -p " origin server username: " susername </dev/tty
  read -sp " origin server password: " spass </dev/tty
  echo
  read -p " cdn url: " cdnurl </dev/tty
  read -p " belugacdn username: " busername </dev/tty
  read -sp " belugacdn password: " bpass </dev/tty
  echo
  echo -e "$susername:$spass@$serverlocation\n$(echo -n $busername:$bpass | openssl base64)\n$cdnurl\ncheck:$(echo -ne "$susername:$spass@$serverlocation\n$(echo -n $busername:$bpass | openssl base64)\n$cdnurl" | md5)" > $HOME/Library/beluga-cli/.defaults
  exit 0
fi

inputflags=''

if [[ -z "$*" ]]; then
  word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli <command> [flags] [arguments]" >&2
  word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
  exit 3
elif [[ $1 != 'rm' && $1 != 'cp' && $1 != 'mv' && $1 != 'iv' && $1 != 'ls' && $1 != 'll' && $1 != 'ftp' && $1 != 'help' ]]; then
  word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli <command> [flags] [arguments]" >&2
  word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
  word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m not a valid command: $1" >&2
  exit 3
else
  count=0
  args=( )
  for command in $@; do
    if [[ $command == 'rm' || $command == 'cp' || $command == 'mv' || $command == 'iv' || $command == 'ls' || $command == 'll' || $command == 'ftp' ]]; then
      let count+=1
    elif [[ ${command:0:1} == '-' ]]; then
      inputflags+=${command/-/}
    else
      args=( ${args[@]} $command )
    fi
  done

  legalflags="isr"

  if [[ $inputflags != $(echo $inputflags | tr -dc $legalflags ) ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli <command> [flags] [arguments]" >&2
    word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    if [[ $(echo $inputflags | tr -d $legalflags | awk '{print length}') -gt 1 ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m unexpected flags -$(echo $inputflags | tr -d $legalflags)"
    else
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m unexpected flag -$(echo $inputflags | tr -d $legalflags)"
    fi
    exit 3
  elif [[ $1 == 'help' && $count -gt 0 ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli <command> [flags] [arguments]" >&2
    word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m use <command> help, not help <command>" >&2
    exit 3
  elif [[ $count -gt 1 ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli <command> [flags] [arguments]" >&2
    word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes multiple commands" >&2
    exit 3
  elif [[ $count -eq 0 && $1 != 'help' ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli <command> [flags] [arguments]" >&2
    word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no commands" >&2
    exit 3
  fi
fi

primarycmd=$1

if [[ $primarycmd == 'help' ]]; then
  display_help_page | less -R
  exit 0
elif [[ $primarycmd == 'ftp' ]]; then
  if [[ ${#inputflags} -gt 0 ]]; then
    msg="unexpected flag: -$inputflags"
    if [[ ${#inputflags} -gt 1 ]]; then
      msg="unexpected flags: -$inputflags"
    fi

    if [[ $inputflags =~ 's' ]]; then
      inputflags=${inputflags//s/}
    fi

    word_wrap $(tput cols) 1 "$msg" >&2
  fi

  if [[ ${args[0]} == 'help' || ${#args[@]} -gt 1 ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli ftp" >&2
    if [[ ${args[0]} == 'help' ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "logs on to the origin server in an interactive ftp session." >&2
      word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
      exit 0
    elif [[ ${#args[@]} -gt 1 ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
      exit 3
    fi
  fi

  ftp ftp://$serverdefault/
  exit $?
elif [[ $primarycmd == 'cp' || $primarycmd == 'mv' || $primarycmd == 'rm' ]]; then
  if [[ $primarycmd == 'rm' ]]; then
    if [[ ${args[0]} == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || ${args[0]:0:6} != 'cdn://' ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli rm [-isr] <cdn://uri>" >&2
      if [[ ${args[0]} == 'help' ]]; then
        word_wrap $(expr $(tput cols) - 1) 1 "deletes a file from the origin server." >&2
        word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
        exit 0
      elif [[ ${#args[@]} -lt 1 ]]; then
        word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
      elif [[ ${#args[@]} -gt 1 ]]; then
        word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
      elif [[ ${args[0]:0:6} != 'cdn://' ]]; then
        word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
      fi
      exit 3
    fi

    remote=${args[0]#cdn:\/\/}
    curroperation='mv'
    local='/dev/null'
    mode="down"
  else
    if [[ $inputflags =~ 'r' ]]; then
      word_wrap $(tput cols) 1 "unexpected flag: -r" >&2
    fi

    curroperation=$primarycmd
    if [[ ${args[0]} == 'help' || ${#args[@]} -gt 2 || ${#args[@]} -lt 2 || ( ${args[0]:0:6} != 'cdn://' && ${args[1]:0:6} != 'cdn://' ) ]]; then
      word_wrap $(expr $(tput cols) - 1) 1:1-8 "usage: beluga-cli $primarycmd [-is] <localpath> <cdn://uri> or <cdn://uri> <localpath> or <cdn://uri> <cdn://uri>" >&2
      if [[ ${args[0]} == 'help' ]]; then
        if [[ $curroperation == 'mv' ]]; then
          word_wrap $(expr $(tput cols) - 1) 1 "moves a file to, from, or within the origin server: of the source and destination, one or both should be remote uris, formatted with cdn:// preceding the path." >&2
        else
          word_wrap $(expr $(tput cols) - 1) 1 "copies a file to, from, or within the origin server: of the source and destination, one or both should be remote uris, formatted with cdn:// preceding the path." >&2
        fi
        word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
        exit 0
      elif [[ ${#args[@]} -lt 2 ]]; then
        word_wrap $(expr $(tput cols) - 1) 1  "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
      elif [[ ( ${args[0]:0:6} != 'cdn://' && ${args[1]:0:6} != 'cdn://' ) ]]; then
        word_wrap $(expr $(tput cols) - 1) 1  "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
      elif [[ ${#args[@]} -gt 2 ]]; then
        word_wrap $(expr $(tput cols) - 1) 1  "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
      fi
      exit 3
    fi


    if [[ ${args[0]:0:6} == 'cdn://' && ${args[1]:0:6} == 'cdn://' ]]; then
      source=${args[0]#cdn:\/\/}
      destination=${args[1]#cdn:\/\/}
      mode="rename"
    else
      if [[ ${args[1]:0:6} == 'cdn://' ]]; then
        local=${args[0]}
        remote=${args[1]#cdn:\/\/}
        mode="up"
      elif [[ ${args[0]:0:6} == 'cdn://' ]]; then
        local=${args[1]}
        remote=${args[0]#cdn:\/\/}
        mode="down"
      fi
    fi

    if [[ $local == '.' ]]; then
      local=$PWD
    elif [[ ${local:0:2} == './' ]]; then
      local="$PWD/${local:2}"
    elif [[ ${local:0:1} == '~' ]]; then
      local=${local/\~/$HOME}
    fi
  fi

  if [[ $mode == "rename" ]]; then
    if [[ -z $source ]]; then
      msg="\033[31;1mfailed:\033[0m http://$cdnurl/ -> http://$cdnurl/$destination"$'\n'"is a directory: http://$cdnurl/"
      display_message "$msg" >&2
      exit 1
    elif [[ ${source:$(expr ${#source} - 1)} == '/' ]]; then
      source=${source:0:$(expr ${#source} - 1)}
    fi

    curl -l "ftp://$serverdefault/$source/" > /dev/null 2> /dev/null
    result=$?

    if [[ $result -eq 0 ]]; then
      msg="\033[31;1mfailed:\033[0m http://$cdnurl/$source/ -> http://$cdnurl/$destination"$'\n'"is a directory: http://$cdnurl/$source/"
      display_message "$msg" >&2
      exit 1
    else
      sourcefile=$(expr "//$source" : '.*/\(.*\)')

      if [[ ${destination:$(expr ${#destination} - 1)} == '/' ]]; then
        destination+=$sourcefile
      else
        if [[ ! -z $destination ]]; then
          curl -l "ftp://$serverdefault/$destination/" > /dev/null 2> /dev/null
          result=$?
          if [[ $result -eq 0 ]]; then
            destination+="/$sourcefile"
          fi
        else
          destination+="/$sourcefile"
        fi
      fi

      if [[ $curroperation == 'mv' ]]; then
        msg="\033[1;92mmoving:\033[0m http://$cdnurl/$source -> http://$cdnurl/$destination"
        tempcurloutput=$(curl "ftp://$serverdefault/$source" -Q "-DELE $sourcefile" 2> /dev/null)
        result=$?
      elif [[ $curroperation == 'cp' ]]; then
        msg="\033[1;92mcopying:\033[0m http://$cdnurl/$source -> http://$cdnurl/$destination"
        tempcurloutput=$(curl "ftp://$serverdefault/$source" 2> /dev/null)
        result=$?
      fi

      display_message "$msg" >&2

      if [[ $result -eq 0 ]]; then
        echo $tempcurloutput | curl -T - "ftp://$serverdefault/$destination" --ftp-create-dirs 2> /dev/null
        result=$?
      fi

      msg=$(validate_curl_result $result)
      curlstatus=$?

      display_message "$msg" >&2

      if [[ $curlstatus -eq 0 && $inputflags =~ 'i' ]]; then
        if [[ $curroperation == 'mv' ]]; then
          invalidate $source
          result1=$?

          invalidate $destination
          result2=$?

          if [[ $result1 -eq $result2 && $result1 -eq 0 ]]; then
            exit 0
          else
            exit 5
          fi
        else
          invalidate $destination
          result=$?
          (( result == 0 )) && exit 0 || exit 5
        fi
      else
        exit $curlstatus
      fi
    fi
  else
    if [[ ! -e $local && $mode == "up" ]]; then
      remotefile=$(expr "//$remote" : '.*/\(.*\)')
      if [[ ! ( $remotefile =~ '.' || -z $remotefile ) ]]; then
        remote+='/'
      fi

      msg="\033[31;1mfailed:\033[0m $local -> http://$cdnurl/$remote"$'\n'"does not exist: $local"
      display_message "$msg" >&2

      exit 1
    elif [[ -d $local && $mode == "up" ]]; then
      if [[ ${local:$(expr ${#local} - 1):1} == '/' ]]; then
        local=${local:0:$(expr ${#local} - 1)}
      fi

      remotefile=$(expr "//$remote" : '.*/\(.*\)')
      if [[ ! ( $remotefile =~ '.' || -z $remotefile ) ]]; then
        remote="$remote/"
      fi

      msg="\033[31;1mfailed:\033[0m $local/ -> http://$cdnurl/$remote"$'\n'"is a directory: $local/"

      display_message "$msg" >&2
      exit 1
    fi

    if [[ ! -z $remote ]]; then
      remoteendchar=${remote:$(expr ${#remote} - 1)}

      if [[ $remoteendchar == '/' ]]; then
        remote=${remote:0:$(expr ${#remote} - 1)}
      fi

      dircontents=$(curl -l "ftp://$serverdefault/$remote/" 2> /dev/null)
      result=$?

      if [[ $result -eq 0 ]]; then # if $remote is a directory...
        if [[ $mode == "down" ]]; then
          if [[ $primarycmd == 'rm' ]]; then
            if [[ $inputflags =~ 'r' ]]; then
              msg="\033[1;92mdeleting:\033[0m http://$cdnurl/$remote/"
              display_message "$msg"

              recursive_delete $remote
              result=$?

              if [[ $result -eq 0 ]]; then
                msg="\033[1;92mdone\033[0m"
              elif [[ $result -eq 5 ]]; then
                msg="\033[1;33mpartly \033[1;33mfailed:\033[0m some files not deleted"
              else
                msg="\033[31;1mfailed:\033[0m http://$cdnurl/$remote/ not deleted"
              fi
            elif [[ -z "$dircontents" ]]; then
              msg="\033[1;92mdeleting:\033[0m http://$cdnurl/$remote/"
              display_message "$msg"
              curl -l "ftp://$serverdefault/" -Q "-RMD $remote" > /dev/null 2> /dev/null
              result=$?
              validationresult=$(validate_curl_result $result)
              result=$?
              word_wrap $(tput cols) 0  "$validationresult" >&2
              exit $result
            else
              msg="\033[1;92mdeleting:\033[0m http://$cdnurl/$remote/"
              display_message "$msg" >&2
              msg="\033[31;1mfailed:\033[0m operation not completed [directory not empty]"
              result=1
            fi
          else
            msg="\033[31;1mfailed:\033[0m http://$cdnurl/$remote/ -> $local"$'\n'"is a directory: http://$cdnurl/$remote/"
            result=1
          fi

          display_message "$msg" >&2

          exit $result # and we are downloading (or deleting)
        elif [[ $mode == "up" ]]; then
          remote+="/$(expr "//$local" : '.*/\(.*\)')"
        fi
      else # if $remote is not a directory
        if [[ $mode == "up" ]]; then # if uploading
          if [[ $remoteendchar == '/' ]]; then # and the user ended the remote uri with a /
            remote+="/$(expr "//$local" : '.*/\(.*\)')" # add the local filename to $remote
          else # if the user didn't end it with a /
            remotefile=$(expr "//$remote" : '.*/\(.*\)')
            localfile=$(expr "//$local" : '.*/\(.*\)')
            if [[ ( ! $remotefile =~ '.' ) && $localfile =~ '.' ]]; then
              # if the local filename has an extension and the remote doesn't,
              # assume it was intended to be a directory
              remote+="/$localfile"
            fi
          fi
        elif [[ $mode == "down" ]]; then # if downloading
          if [[ $remoteendchar == '/' ]]; then
            # if the user included a / where there shouldn't be one,
            # tell them the verbatim file doesn't exist (even if it otherwise might)
            msg="\033[31;1mfailed:\033[0m http://$cdnurl/$remote/ -> $local"$'\n'"does not exist: $remote/"
            display_message "$msg" >&2
            exit 1
          fi
        fi
      fi
    else
      if [[ $mode == "up" ]]; then
        remote=$(expr "//$local" : '.*/\(.*\)')
      elif [[ $mode == "down" ]]; then
        if [[ $primarycmd == 'rm' ]]; then
          msg="\033[31;1mfailed:\033[0m deleting http://$cdnurl/"$'\n'"is a directory: http://$cdnurl/"
        else
          msg="\033[31;1mfailed:\033[0m http://$cdnurl/ -> $local"$'\n'"is a directory: http://$cdnurl/"
        fi
        display_message "$msg" >&2
        exit 1
      fi
    fi

    if [[ $mode == "up" ]]; then
      if [[ $curroperation == "cp" ]]; then
        msg="\033[1;92muploading:\033[0m $local -> http://$cdnurl/$remote"
        curl -T "$local" "ftp://$serverdefault/$remote" --ftp-create-dirs 2> /dev/null
        result=$?
      elif [[ $curroperation == "mv" ]]; then
        msg="\033[1;92mmoving:\033[0m $local -> http://$cdnurl/$remote"
        curl -T "$local" "ftp://$serverdefault/$remote" --ftp-create-dirs 2> /dev/null
        result=$?
        if [[ $result -eq 0 ]]; then
          rm $local
          result=$?
        fi
      fi
    elif [[ $mode == "down" ]]; then
      remotefile=$(expr "//$remote" : '.*/\(.*\)')

      if [[ ${local:$(expr ${#local} - 1):1} != '/' ]]; then # if the local path doesn't end with a /...
        if [[ -d "$local" ]]; then
          # if $local refers to an existing directory nevertheless,
          # the filename should be the same as the remote filename
          local+="/$remotefile"
        elif [[ $local != '/dev/null' ]]; then
          localfile=$(expr "//$local" : '.*/\(.*\)')
          remotefile=$(expr "//$remote" : '.*/\(.*\)')

          if [[ ( ! $localfile =~ '.' ) && $remotefile =~ '.' ]]; then
            # if the localfile has no extension but the remote
            # file does, assume it is meant to refer to a directory
            if [[ ! ( -d "$local" ) ]]; then
              # if the directory doesn't exist, create it
              mkdir -p "$local"
            fi
            # the local filename should be the same as the remote
            local+="/$remotefile"
          else
            if [[ ! -d "${local%\/*}" ]]; then
              # if the local path without the filename doesn't exist,
              # create it
              mkdir -p "${local%\/*}"
            fi
          fi
        fi
      else # if the local path does end with /
        if [[ ! -d "$local" ]]; then # create the directory if it didn't already exist
          mkdir -p "$local"
        fi

        local+="$remotefile"
      fi

      if [[ $curroperation == "cp" ]]; then
        msg="\033[1;92mdownloading:\033[0m http://$cdnurl/$remote -> $local"
        curl "ftp://$serverdefault/$remote" -o "$local" 2> /dev/null
        result=$?
      elif [[ $curroperation == "mv" ]]; then
        if [[ $primarycmd == 'rm' ]]; then
          msg="\033[1;92mdeleting:\033[0m http://$cdnurl/$remote"
        else
          msg="\033[1;92mmoving:\033[0m http://$cdnurl/$remote -> $local"
        fi
        curl "ftp://$serverdefault/$remote" -Q "-DELE $remotefile" -o "$local" 2> /dev/null
        result=$?
      fi
    fi
  fi

  display_message "$msg" >&2

  validationresult=$(validate_curl_result $result)
  result=$?

  word_wrap $(tput cols) 0  "$validationresult" >&2

  if [[ $result -eq 0 ]]; then
    if [[ ( $mode == "up" || $primarycmd == "rm" ) && $inputflags =~ 'i' ]]; then
      invalidate $remote
      result=$?
    fi
  fi
  exit $result
elif [[ $primarycmd == 'iv' ]]; then
  if [[ $inputflags =~ 'i' || $inputflags =~ 'r' ]]; then
    if [[ $(echo $inputflags | tr -dc 'ir' | awk '{print length}') -gt 1 ]]; then
      word_wrap $(tput cols) 1 "unexpected flags: -$(echo $inputflags | tr -dc 'ir')" >&2
    else
      word_wrap $(tput cols) 1 "unexpected flag: -$(echo $inputflags | tr -dc 'ir')" >&2
    fi
  fi

  if [[ ${args[0]} == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || ${args[0]:0:6} != 'cdn://' ]]; then
    word_wrap $(expr $(tput cols) - 1) 1 "usage: beluga-cli $primarycmd [-s] <cdn://uri>" >&2
    if [[ ${args[0]} == 'help' ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "invalidates a file so it must be retrieved again from the origin server." >&2
      word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    elif [[ ${#args[@]} -lt 1 ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
    elif [[ ${#args[@]} -gt 1 ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
    elif [[ ${args[0]:0:6} != 'cdn://' ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
    fi
    exit 3
  else
    destinationpath=${args[0]#cdn:\/\/}

    invalidate $destinationpath
  fi
elif [[ $primarycmd == 'ls' || $primarycmd == 'll' ]]; then
  if [[ ${#inputflags} -gt 0 ]]; then
    msg="unexpected flag: -$inputflags"
    if [[ ${#inputflags} -gt 1 ]]; then
      msg="unexpected flags: -$inputflags"
    fi

    if [[ $inputflags =~ 's' ]]; then
      inputflags=${inputflags//s/}
    fi

    word_wrap $(tput cols) 1 "$msg" >&2
  fi


  if [[ ${args[0]} == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || ${args[0]:0:6} != 'cdn://' ]]; then
    word_wrap $(expr $(tput cols) - 1) 1  "usage: beluga-cli $primarycmd <cdn://uri>" >&2
    if [[ ${args[0]} == 'help' ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "retrieves and lists the contents of a specified directory on the origin." >&2
      word_wrap $(expr $(tput cols) - 1) 1 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    elif [[ ${#args[@]} -lt 1 ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
    elif [[ ${#args[@]} -gt 1 ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
    elif [[ ${args[0]:0:6} != 'cdn://' ]]; then
      word_wrap $(expr $(tput cols) - 1) 1 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
    fi
    exit 3
  fi

  remote=${args[0]#cdn:\/\/}

  endchar=${remote:$(expr ${#remote} - 1):1}

  if [[ $endchar != '/' && ! -z $remote ]]; then
    remote+='/'
  fi

  myurl=http://$cdnurl/$remote

  msg="\033[1;92mlisting contents of\033[0m $myurl"

  display_message "$msg" >&2

  if [[ $primarycmd == 'ls' ]]; then
    listing=$(curl -l "ftp://$serverdefault/$remote" 2> /dev/null)
    result=$?
  elif [[ $primarycmd == 'll' ]]; then
    listing=$(curl "ftp://$serverdefault/$remote" 2> /dev/null)
    result=$?
  fi

  validationresult=$(validate_curl_result $result)
  exitstatus=$?

  if [[ $exitstatus -eq 0 ]]; then
    echo -e "\033[1;92msuccess\033[0m" >&2
    echo -e "$listing"
  else
    word_wrap $(tput cols) 0  "$validationresult" >&2
  fi
fi
