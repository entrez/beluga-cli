#!/usr/bin/env bash

# beluga-cli
VERSION_NUMBER="v0.7.0"
# exit codes:
#  0 success
#  1 failure: operation aborted
#  2 invalidation request already pending
#  3 illegal input
#  4 missing config
#  5 partial failure

update_self ( ) {
  local msg="checking for new version of beluga-cli"
  word_wrap $(tput cols) 0 "$msg" >&2

  local script_location="$(dirname "$0")/$(basename "$0")"
  local item_head
  item_head=$(curl -s -r 0-75 "https://raw.githubusercontent.com/entrez/beluga-cli/master/beluga-cli")
  local exit_code=$?

  if [[ $exit_code -ne 0 ]]; then
    msg=$(validate_curl_result $exit_code)
  elif [[ $item_head =~ "404: Not Found" ]]; then
    msg="\033[31;1mfailed:\033[0m operation not completed [HTTP 404]"
    exit_code=1
  else
    local new_version=""

    local IFS=$'\n'
    for line in $item_head; do
      if [[ ${line:0:15} == "VERSION_NUMBER=" ]]; then
        new_version=${line:16:${#line}-17}
        new_version=${new_version#'v'}
        break
      fi
    done

    if [[ $new_version == "" ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [can't find version #]"
      exit_code=1
    else
      local do_update=0
      for n in $(seq 1 3); do
        if [[ $(echo $new_version | cut -d'.' -f$n) -gt $(echo ${VERSION_NUMBER:1} | cut -d'.' -f$n) ]]; then
          do_update=1
          break
        elif [[ $(echo $new_version | cut -d'.' -f$n) -lt $(echo ${VERSION_NUMBER:1} | cut -d'.' -f$n) ]]; then
          do_update=0
          break
        fi
      done

      if [[ $do_update -eq 1 ]]; then
        msg="\033[1;92msuccess:\033[0m updating beluga-cli from version ${VERSION_NUMBER:1} to version $new_version" >&2
        curl -s https://raw.githubusercontent.com/entrez/beluga-cli/master/beluga-cli -o $script_location
        exit_code=$?
        msg=$(validate_curl_result $exit_code)
        if [[ $exit_code -eq 0 ]]; then
          local man_status=$(curl -s -r 0-1 https://raw.githubusercontent.com/entrez/beluga-cli/master/man/beluga-cli.1)
          if [[ ! "$man_status" =~ "404: Not Found" ]]; then
            test -d "$HOME/.beluga-cli/man" || mkdir -p "$HOME/.beluga-cli/man"
            curl -s https://raw.githubusercontent.com/entrez/beluga-cli/master/man/beluga-cli.1 -o $HOME/.beluga-cli/man/beluga-cli.1
            exit_code=$?
            if [[ $exit_code -eq 0 && ! -e "/usr/local/share/man/man1/beluga-cli.1" ]]; then
              ln -s "$HOME/.beluga-cli/man/beluga-cli.1" "/usr/local/share/man/man1/beluga-cli.1" && $(test "$(uname -s)" == "Darwin" && /usr/libexec/makewhatis /usr/local/share/man || mandb -u)
              exit_code=$?
            fi
          else
            exit_code=1
          fi
          if [[ $exit_code -ne 0 ]]; then
            word_wrap $(tput cols) 0 "$msg" >&2
            word_wrap $(tput cols) 0 "\033[1;33mwarning:\033[0m problem updating manpage" >&2
            exit 5
          fi
        fi
      else
        msg="\033[1;92mdone:\033[0m you already have the latest version of beluga-cli ($VERSION_NUMBER)"
        exit_code=0
      fi
    fi
  fi

  word_wrap $(tput cols) 0 "$msg" >&2
  exit $exit_code
}

# beluga_api [ --token-id=<id> --token-secret=<secret> ] [ --user=<user> --password=<pass> ]
# --request-method=<method> --request-path=<path> [ --request-body=<body> ]
#
# both token authentication and basic authentication are possible, depending on whether
# --token-id and --token-secret or --user and --password are included.
beluga_api ( ) {
  IFS=$' '

  for item in "$@"; do
    if [[ ${item:0:11} == "--token-id=" ]]; then
      local tokenid=${item##*=}
    elif [[ ${item:0:15} == "--token-secret=" ]]; then
      local tokensecret=${item##*=}
    elif [[ ${item:0:7} == "--user=" ]]; then
      local buser=${item##*=}
    elif [[ ${item:0:11} == "--password=" ]]; then
      local bpassword=${item#--password=}
    elif [[ ${item:0:17} == "--request-method=" ]]; then
      local requestmethod=${item##*=}
    elif [[ ${item:0:15} == "--request-path=" ]]; then
      local requestpath=${item##*=}
    elif [[ ${item:0:15} == "--request-body=" ]]; then
      local requestbody=${item##*=}
    fi
  done

  # list sites:
  # requestpath='/api/cdn/v2/sites'
  # requestmethod='GET'

  # invalidation:
  # beluga_api --token-id= --token-secret= --request-method=POST --request-path=/api/cdn/v2/invalidations --request-body="{\"urls\":[{\"url\":\"$myurl\"}], \"limit-records\": \"50000\"}"
  # requestmethod='POST'
  # requestpath='/api/cdn/v2/invalidations'
  # requestbody="{\"urls\":[{\"url\":\"$myurl\"}], \"limit-records\": \"50000\"}"

  local requesturlbase='https://api.belugacdn.com'

  local isodate=$(gdate -u "+%Y-%m-%dT%H:%M:%S.%6NZ" 2> /dev/null)
  if [[ $? -eq 127 ]]; then
    isodate=$(date -u "+%Y-%m-%dT%H:%M:%S.%6NZ")
  fi

  # TOKEN AUTHENTICATION
  local signstring="$requestmethod:$requestpath:$isodate"

  if [[ ( $requestmethod == 'POST' || $requestmethod == 'PUT' ) && ! -z $requestbody ]]; then
    local bodyhash=$(echo -n $requestbody | openssl sha512)
    if [[ ${bodyhash:0:9} == "(stdin)= " ]]; then
      bodyhash=${bodyhash:9}
    fi
    signstring="$signstring:$bodyhash"
  fi

  if [[ ! ( -z $tokenid || -z $tokensecret) ]]; then
    local signhmac=$(echo -n "$signstring" | openssl sha512 -hmac "$tokensecret")
    if [[ ${signhmac:0:9} == "(stdin)= " ]]; then
      signhmac=${signhmac:9}
    fi
    local authheader="Token $tokenid $signhmac"
  elif [[ ! ( -z "$buser" || -z "$bpassword" ) ]]; then
    local authheader="Basic $(echo -n "$buser:$bpassword" | openssl base64)"
  fi

  if [[ ! -z $requestbody ]]; then
    curl -kH "Content-type: application/json" \
         -H "Accept: application/json" \
         -H "Date: $isodate" \
         -H "Authorization: $authheader" \
         -d "$requestbody" "$requesturlbase$requestpath" 2> /dev/null
    return $?
  else
    curl -kH "Accept: application/json" \
         -H "Date: $isodate" \
         -H "Authorization: $authheader" \
         "$requesturlbase$requestpath" 2> /dev/null
    return $?
  fi
}

# usage: display_message <message>
# attempts to constrain status messages to fit the current terminal size, by
# replacing certain substrings with shorter aliases, etc
display_message ( ) {
  if [[ ! $inputflags =~ 's' ]]; then
    IFS=$'\n'
    local line
    for line in $1; do
      if [[ `echo -e $line | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}'` -gt $(tput cols) ]]; then
        if [[ $line != ${line//$HOME/\~} ]]; then
          line=${line//$HOME/\~}
        fi

        if [[ `echo -e $line | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}'` -gt $(tput cols) ]]; then
          if [[ $line =~ "http://$cdnurl" ]]; then
            line=${line//http:\/\/$cdnurl/cdn:/}
            line=${line//%20/ }
          fi
        fi

        while [[ `echo -e $line | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}'` -gt $(tput cols) ]]; do
          local shortl=''
          IFS=' '
          for part in $line; do
            if [[ `echo $part | tr -dc '/' | awk '{print length}'` -gt 0 ]]; then
              if [[ ${part:0:6} == 'cdn://' ]]; then
                part=${part#cdn:\/\/}
                part=${part#\.\.\.}
                shortl+="cdn://...${part#*?\/} "
              else
                shortl+="...${part#*?\/} "
              fi
            else
              shortl+="$part "
            fi
          done

          if [[ "$line" == "$(echo $shortl | awk '{$1=$1};1')" ]]; then
            break
          else
            line=$(echo $shortl | awk '{$1=$1};1')
          fi
        done
      fi
      word_wrap $(tput cols) 0 "$line"
    done
  fi
}

# usage: validate_curl_result <result>
# interprets certain relevant curl exit codes
#
# exit codes:
#  0 success
#  1 failure
validate_curl_result ( ) {
  local res=$1

  if [[ ! $res -eq 0 ]]; then
    local msg="\033[31;1mfailed:\033[0m operation not completed [error $res"
    if [[ $res -eq 78 ]]; then
      msg+=": file not found"
    elif [[ $res -eq 6 ]]; then
      msg+=": couldn't resolve host"
    elif [[ $res -eq 7 ]]; then
      msg+=": failed to connect"
    elif [[ $res -eq 8 ]]; then
      msg+=": unknown response"
    elif [[ $res -eq 9 ]]; then
      msg+=": ftp access denied"
    elif [[ $res -eq 10 ]]; then
      msg+=": accept failed"
    elif [[ $res -eq 11 ]]; then
      msg+=": weird PASS reply"
    elif [[ $res -eq 12 ]]; then
      msg+=": timeout expired"
    elif [[ $res -eq 13 ]]; then
      msg+=": weird PASV reply"
    elif [[ $res -eq 14 ]]; then
      msg+=": unknown FTP 227 format"
    elif [[ $res -eq 15 ]]; then
      msg+=": couldn't get host"
    elif [[ $res -eq 17 ]]; then
      msg+=": couldn't set binary"
    elif [[ $res -eq 19 ]]; then
      msg+=": couldn't access file"
    elif [[ $res -eq 21 ]]; then
      msg+=": QUOT cmd failed"
    elif [[ $res -eq 23 ]]; then
      msg+=": write error"
    elif [[ $res -eq 27 ]]; then
      msg+=": out of memory"
    elif [[ $res -eq 28 ]]; then
      msg+=": operation timeout"
    elif [[ $res -eq 30 ]]; then
      msg+=": PORT failed"
    elif [[ $res -eq 31 ]]; then
      msg+=": couldn't use REST"
    elif [[ $res -eq 78 ]]; then
      msg+=": remote file does not exist"
    elif [[ $res -eq 87 ]]; then
      msg+=": can't parse file list"
    fi
    msg+="]"
    echo -e "$msg"
    return 1
  else
    echo -e "\033[1;92mdone\033[0m"
    return 0
  fi
}

# usage: center_text <text>
# centers text in terminal window
center_text ( ) {
  IFS=$'\n'
  left_pad=$(expr $(expr $(tput cols) - $(echo -e $1 | tr -d '\n' | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}')) / 2)
  tab=''
  if [[ $left_pad -gt 0 ]]; then
    for n in $(seq 0 $left_pad); do
      tab+=$' '
    done
  fi

  echo -e "$tab$1"
}

# usage: word_wrap <maxlinelength> [a- or <numuntabbedlines>- or
# <numinitiallines>:<initiallefttab>-]<lefttab> <text>
#
# arguments:
#  maxlinelength: max length of each line, including initial tab
#  numuntabbedlines: number of initial lines with no tab. can also be set to
#                    the letter 'a' for 'append mode' (to add to an existing
#                    line)
#  numinitiallines: num. of initial lines w/ tab of length 'initiallefttab'
#  initiallefttab: length of tab for 'numinitiallines' initial lines
#  lefttab: length of tab after 'numinitiallines' or 'numuntabbedlins', or,
#           if used alone, tab length for entire paragraph.
#  text: text to be displayed with word wrap
#
# for example, `word_wrap 30 1:4-8 $msg` would print $msg in the following
# format, where no line is longer than 30 characters total, the first line
# has a 4 space left tab, the following lines have an 8 space tab, and "word
# wrap" is enabled (initial 'tab' spaces represented by periods for clarity):
#  ....Lorem ipsum dolor sit amet
#  ........consectetur adipiscing
#  ........elit. Maecenas
#  ........convallis, leo non
#  ........sollicitudin molestie.
#
# it should work fine with all ANSI color codes.
word_wrap ( ) {
  if [[ ! $inputflags =~ 's' ]]; then
    IFS=$' '
    maxlength=$1

    if [[ $2 =~ '-' ]]; then
      tab=$(echo $2 | cut -d'-' -f2 )
      start=$(echo $2 | cut -d'-' -f1 )
      starttab=0
      if [[ $start == 'a' ]]; then
        start=1
        mode='append'
      elif [[ $start =~ ':' ]]; then
        start=$(echo $2 | cut -d'-' -f1 | cut -d':' -f1)
        starttab=$(echo $2 | cut -d'-' -f1 | cut -d':' -f2)
      fi
    else
      tab=$2
      start=0
    fi

    curritems=( $(echo -e $@) )
    currline=${curritems[2]}

    linenum=1
    for word in ${curritems[@]:3}; do
      if [[ $linenum -gt $start ]] || [[ $mode == 'append' ]]; then
        max=$(expr $maxlength - $tab)
      else
        max=$(expr $maxlength - $starttab)
      fi

      if [[ $(echo "$currline $word" | sed "s,$(echo -e '\033')\\[[0-9;]*[a-zA-Z],,g" | awk '{print length}') -lt $max ]]; then
        currline="$currline $word"
      else
        if [[ $linenum -gt $start ]]; then
          for ((n=0;n<$tab;n++)); do
            echo -n ' '
          done
        else
          for ((n=0;n<$starttab;n++)); do
            echo -n ' '
          done
        fi
        echo -e $currline
        currline=$word
        let linenum++
      fi
    done

    if [[ $linenum -gt $start ]]; then
      for ((n=0;n<$tab;n++)); do
        echo -n ' '
      done
    else
      for ((n=0;n<$starttab;n++)); do
        echo -n ' '
      done
    fi
    echo $currline
  fi
}

# usage: invalidate <path>
# sends an invalidation request to beluga via their api and displays the result
#
# exit codes:
#  0  success
#  1  failure
#  2  uri invalidation already pending
#
invalidate ( ) {
  local myurl=http://$cdnurl/$1

  msg="\033[1;92minvalidating:\033[0m $myurl"
  display_message "$msg" >&2

  resp=$(beluga_api --token-id=$tokenid --token-secret=$tokensecret --request-method=POST --request-path=/api/cdn/v2/invalidations --request-body="{\"urls\":[{\"url\":\"$myurl\"}], \"limit-records\": \"50000\"}")
  result=$?

  if [[ $resp =~ "TokenID is not numeric" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [invalid token id]"
    exitstatus=1
  elif [[ $resp =~ "password mismatch" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [user/password incorrect]"
    exitstatus=1
  elif [[ $resp =~ "token lookup failed" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [token id lookup failed]"
    exitstatus=1
  elif [[ $resp =~ "token validation failed" ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [token validation failed]"
    exitstatus=1
  elif [[ $resp =~ '"httpMessage":"Unauthorized"' ]]; then
    validationresult="\033[31;1mfailed:\033[0m operation not completed [401 unauthorized]"
    exitstatus=1
  else
    curlstatus=$(echo $resp | cut -d',' -f3 | tr -d '"' | cut -d':' -f2)

    validationresult=$(validate_curl_result $result)
    exitstatus=$?
  fi

  if [[ $exitstatus -eq 0 ]]; then
    if [[ $curlstatus == "pending" ]]; then
      word_wrap $(tput cols) 0 "request \033[1;92mpending\033[0m" >&2
      return 0
    elif [[ $curlstatus == "previously-pending" ]]; then
      word_wrap $(tput cols) 0 "request \033[1;33mpreviously pending\033[0m" >&2
      return 2
    elif [[ $curlstatus == "failure" ]]; then
      word_wrap $(tput cols) 0 "request \033[1;91mfailed\033[0m" >&2
      return 1
    else
      word_wrap $(tput cols) 0 "request $curlstatus" >&2
      return $exitstatus
    fi
  else
    word_wrap $(tput cols) 0 "$validationresult" >&2
    return $exitstatus
  fi
}

# usage: recursive_delete <path>
#
# exit codes:
#  0 success
#  1 total failure
#  5 partial failure
recursive_delete ( ) {
  local path=$1
  local totalnum=0
  local failnum=0

  filelist=$(curl -l "ftp://$serverdefault/$path/" 2> /dev/null)
  local lresult=$?

  IFS=$'\n'
  if [[ $lresult -eq 0 ]]; then
    for item in $filelist; do
      recursive_delete "$path/$item"
    done
    curl -l "ftp://$serverdefault/" -Q "-RMD $path" > /dev/null 2> /dev/null
    lresult=$?
    let totalnum++

    if [[ $lresult -ne 0 ]]; then
      display_message "\033[31;1merror\033[0m deleting cdn://$path/" >&2
      let failnum++
    fi
  else
    curl -l "ftp://$serverdefault/" -Q "-DELE $path" > /dev/null 2> /dev/null
    lresult=$?
    let totalnum++

    if [[ $lresult -ne 0 ]]; then
      display_message "\033[31;1merror\033[0m deleting cdn://$path" >&2
      let failnum++
    elif [[ $inputflags =~ 'i' ]]; then
      invalidate $path
    fi
  fi

  if [[ $failnum -eq $totalnum ]]; then
    return 1
  elif [[ $failnum -gt 0 ]]; then
    return 5
  else
    return 0
  fi
}

inputflags=''

if [[ -z "$*" ]]; then
  word_wrap $(tput cols) 1-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
  word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
  word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
  exit 3
elif [[ $1 != 'rm' && $1 != 'cp' && $1 != 'mv' && $1 != 'iv' && $1 != 'ls' && $1 != 'll' && $1 != 'ftp' && $1 != 'help' && $1 != 'mkdir' && $1 != 'config' && $1 != 'update' ]]; then
  word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
  word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
  word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
  word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m not a valid command: $1" >&2
  exit 3
else
  count=0
  args=( )
  for command in "$@"; do
    if [[ $command == 'rm' || $command == 'cp' || $command == 'mv' || $command == 'iv' || $command == 'ls' || $command == 'll' || $command == 'ftp' || $command == 'mkdir' || $command == 'config' || $command == 'update' ]]; then
      let count+=1
    elif [[ ${command:0:10} == "--profile=" ]]; then
      profilename=${command:10}
    elif [[ ${command:0:2} == '--' ]]; then
      inputflags=${inputflags//s/}
      word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
      word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
      word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m unexpected option $command"
      exit 3
    elif [[ ${command:0:1} == '-' ]]; then
      inputflags+=${command/-/}
    else
      args=( "${args[@]}" "$command" )
    fi
  done

  if [[ -z "$profilename" ]]; then
    profilename="default"
  fi

  legalflags="isrpc"

  if [[ $inputflags != $(echo $inputflags | tr -dc $legalflags ) ]]; then
    inputflags=${inputflags//s/}
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
    word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
    word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    if [[ $(echo $inputflags | tr -d $legalflags | awk '{print length}') -gt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m unexpected options -$(echo $inputflags | tr -d $legalflags)"
    else
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m unexpected option -$(echo $inputflags | tr -d $legalflags)"
    fi
    exit 3
  elif [[ $1 == 'help' && $count -gt 0 ]]; then
    inputflags=${inputflags//s/}
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
    word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
    word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m use <command> help, not help <command>" >&2
    exit 3
  elif [[ $count -gt 1 ]]; then
    inputflags=${inputflags//s/}
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
    word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
    word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes multiple commands" >&2
    exit 3
  elif [[ $count -eq 0 && $1 != 'help' ]]; then
    inputflags=${inputflags//s/}
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
    word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
    word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no commands" >&2
    exit 3
  fi
fi

if [[ -e "$HOME/.beluga-cli/credentials" && $1 != "config" && $1 != "update" ]]; then

  #Credentials structure:
  #[default]
  #cdn_url=
  #origin=
  #origin_user=
  #origin_pass=
  #beluga_token_id=
  #beluga_token_secret=

  IFS=$' \n'
  credentialsf=( $(cat $HOME/.beluga-cli/credentials) )
  for n in $(seq 0 $(expr ${#credentialsf[@]} - 1)); do
    if [[ "${credentialsf[$n]}" == "[$profilename]" ]]; then
      credentials=( "${credentialsf[@]:$n+1:6}" )
      break
    fi
  done

  if [[ ${#credentials[@]} -gt 0 ]]; then
    for n in $(seq 0 $(expr ${#credentials[@]} - 1)); do
      line="${credentials[$n]}"
      if [[ "${line:0:8}" == "cdn_url=" ]]; then
        cdnurl="${line:8}"
      elif [[ "${line:0:7}" == "origin=" ]]; then
        serverloc="${line:7}"
      elif [[ "${line:0:12}" == "origin_user=" ]]; then
        suser="${line:12}"
      elif [[ "${line:0:12}" == "origin_pass=" ]]; then
        spass="${line:12}"
      elif [[ "${line:0:16}" == "beluga_token_id=" ]]; then
        tokenid="${line:16}"
      elif [[ "${line:0:20}" == "beluga_token_secret=" ]]; then
        tokensecret="${line:20}"
      fi
    done
  fi

  if [[ -z $cdnurl || -z $serverloc || -z $suser || -z $spass || -z $tokenid || -z $tokensecret ]]; then
    if [[ $profilename == "default" ]]; then
      word_wrap $(tput cols) 0 "\033[31;1merror:\033[0m bad credentials" >&2
      word_wrap $(tput cols) 0 "run \033[37;1mbeluga-cli \033[37;1mconfig\033[0m, or \033[37;1mbeluga-cli \033[37;1mhelp\033[0m for more info." >&2
    else
      word_wrap $(tput cols) 0 "\033[31;1merror:\033[0m bad credentials [$profilename]" >&2
      word_wrap $(tput cols) 0 "run \033[37;1mbeluga-cli \033[37;1mconfig \033[37;1m--profile=$profilename\033[0m, or \033[37;1mbeluga-cli \033[37;1mhelp\033[0m for more info." >&2
    fi
    exit 4
  fi

  if [[ ${serverloc:$(expr ${#serverloc} - 1)} == '/' ]]; then
    serverloc=${serverloc:0:$(expr ${#serverloc} - 1)}
  fi

  if [[ ${serverloc:0:6} == 'ftp://' ]]; then
    serverloc=${serverloc:6}
  fi

  serverdefault="$suser:$spass@$serverloc"

  if [[ ${cdnurl:$(expr ${#cdnurl} - 1)} == '/' ]]; then
    cdnurl=${cdnurl:0:$(expr ${#cdnurl} - 1)}
  fi

  if [[ ${cdnurl:0:7} == 'http://' ]]; then
    cdnurl=${cdnurl:7}
  elif [[ ${cdnurl:0:8} == 'https://' ]]; then
    cdnurl=${cdnurl:8}
  fi
fi

if [[ $1 != "help" && $1 != "config" && $1 != "update" ]]; then
  if [[ ! -d "$HOME/.beluga-cli" ]]; then
    word_wrap $(tput cols) 0 "\033[31;1merror:\033[0m missing config directory ~/.beluga-cli. run \033[1mbeluga-cli config\033[0m to configure defaults, or \033[1mbeluga-cli \033[1mhelp\033[0m for more information." >&2
    exit 4
  elif [[ ! -e "$HOME/.beluga-cli/credentials" ]]; then
    word_wrap $(tput cols) 0 "\033[31;1merror:\033[0m missing config file ~/.beluga-cli/credentials. run \033[1mbeluga-cli config\033[0m to configure defaults, or \033[1mbeluga-cli \033[1mhelp\033[0m for more information." >&2
    exit 4
  fi
elif [[ $1 == "config" ]]; then
  inputflags=${inputflags//s/}
  if [[ ! -d "$HOME/.beluga-cli" ]]; then
    mkdir "$HOME/.beluga-cli"
  fi
  if [[ ! -e "$HOME/.beluga-cli/credentials" ]]; then
    touch "$HOME/.beluga-cli/credentials"
    if [[ ! ( -r "$HOME/.beluga-cli/credentials" && -w "$HOME/.beluga-cli/credentials" ) ]]; then
      chmod +rw-x "$HOME/.beluga-cli/credentials" 2>/dev/null || (word_wrap $(tput cols) 0 "\033[31;1merror:\033[0m can't change read/write bits for $HOME/.beluga-cli/credentials" >&2; exit 4)
    fi
  fi
  echo
  word_wrap $(tput cols) 0 "\033[31;1mcaution:\033[0m your origin server username and password will be stored and transmitted as plain text, so ensure they are not used elsewhere." >&2
  word_wrap $(tput cols) 0 "run \033[1mbeluga-cli \033[1mhelp\033[0m and see the section 'configuration' for more information on what to enter here." >&2
  echo
  read -p "origin server location: ftp://" serverlocation </dev/tty
  read -p "origin server username: " susername </dev/tty
  read -p "origin server password: " spass </dev/tty
  echo
  read -p "cdn url: " cdnurl </dev/tty
  echo
  read -n1 -sp "use an [e]xisting token for beluga authentication, or [G]enerate a new one? " tchoice </dev/tty
  while [[ ! ( $(echo $tchoice | tr "[:upper:]" "[:lower:]") == 'g' || $(echo $tchoice | tr "[:upper:]" "[:lower:]") == 'e' || $tchoice == '' ) ]]; do
    read -n1 -s tchoice </dev/tty
  done
  echo

  if [[ $(echo $tchoice | tr "[:upper:]" "[:lower:]") == 'e' ]]; then
    read -p "token id: " id </dev/tty
    read -p "token secret: " secret </dev/tty
    echo
  else
    read -p "belugacdn username: " busername </dev/tty
    read -sp "belugacdn password: " bpass </dev/tty
    echo -e "\n"
    echo "generating token..." >&2

    resp=$(beluga_api --user="$busername" --password="$bpass" --request-method=POST --request-path=/api/token/token --request-body='{"description": "beluga-cli token"}')
    exit_code=$?

    if [[ $resp =~ "password mismatch" ]]; then
      word_wrap $(tput cols) 0 "\033[31;1mfailed:\033[0m token not created [user/password incorrect]" >&2
      exit 1
    elif [[ $exit_code -ne 0 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1mfailed:\033[0m token not created [unknown error $exit_code]" >&2
      exit 1
    else
      echo -e "\033[1;92mdone\033[0m"
      echo
      id=$(echo $resp | cut -d',' -f4 | tr -d '"' | cut -d':' -f2 | awk '{$1=$1};1')
      secret=$(echo $resp | cut -d',' -f1 | tr -d '"' | cut -d':' -f2 | awk '{$1=$1};1')
    fi
  fi

  IFS=$' \n'
  credentialsf=( $(cat $HOME/.beluga-cli/credentials) )
  for n in $(seq 0 $(expr ${#credentialsf[@]} - 1)); do
    if [[ "${credentialsf[$n]}" == "[$profilename]" ]]; then
      cn=$n
      break
    fi
  done

  if [[ -z $cn ]]; then
    echo -e "[$profilename]\ncdn_url=$cdnurl\norigin=$serverlocation\norigin_user=$susername\norigin_pass=$spass\nbeluga_token_id=$id\nbeluga_token_secret=$secret" >> $HOME/.beluga-cli/credentials
  else
    sed -i'.old' "$(expr $cn + 2)s/.*/cdn_url=${cdnurl//\//\\\/}/" $HOME/.beluga-cli/credentials
    sed -i'.old' "$(expr $cn + 3)s/.*/origin=${serverlocation//\//\\\/}/" $HOME/.beluga-cli/credentials
    sed -i'.old' "$(expr $cn + 4)s/.*/origin_user=${susername//\//\\\/}/" $HOME/.beluga-cli/credentials
    sed -i'.old' "$(expr $cn + 5)s/.*/origin_pass=${spass//\//\\\/}/" $HOME/.beluga-cli/credentials
    sed -i'.old' "$(expr $cn + 6)s/.*/beluga_token_id=${id//\//\\\/}/" $HOME/.beluga-cli/credentials
    sed -i'.old' "$(expr $cn + 7)s/.*/beluga_token_secret=${secret//\//\\\/}/" $HOME/.beluga-cli/credentials
    rm $HOME/.beluga-cli/credentials.old
  fi
  exit 0
elif [[ $1 == "update" ]]; then
  update_self
  exit $?
fi

primarycmd=$1

if [[ $primarycmd == 'help' ]]; then
  inputflags=${inputflags//s/}
  man -W beluga-cli 1>/dev/null 2>&1
  if [[ $? -eq 0 ]]; then
    man beluga-cli
  elif [[ -e "$HOME/.beluga-cli/man/beluga-cli.1" ]]; then
    man "$HOME/.beluga-cli/man/beluga-cli.1"
  else
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli <command> [<options>] [<arguments>] [--profile=<profilename>]" >&2
    word_wrap $(tput cols) 1-10 "commands: cp, mv, rm, mkdir, ftp, ls, ll, iv, update, help, config" >&2
  fi
  exit 0
elif [[ $primarycmd == 'ftp' ]]; then
  if [[ ${#inputflags} -gt 0 ]]; then
    msg="unexpected option: -$inputflags"
    if [[ ${#inputflags} -gt 1 ]]; then
      msg="unexpected options: -$inputflags"
    fi

    if [[ $inputflags =~ 's' ]]; then
      inputflags=${inputflags//s/}
    fi

    word_wrap $(tput cols) 1 "$msg" >&2
  fi

  if [[ "${args[0]}" == 'help' || ${#args[@]} -gt 0 ]]; then
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli ftp" >&2
    if [[ "${args[0]}" == 'help' ]]; then
      word_wrap $(tput cols) 0 "logs on to the origin server in an interactive ftp session." >&2
      word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
      exit 0
    elif [[ ${#args[@]} -gt 0 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
      exit 3
    fi
  fi

  ftp ftp://$serverdefault/
  exit $?
elif [[ $primarycmd == 'cp' || $primarycmd == 'mv' || $primarycmd == 'rm' ]]; then
  if [[ $primarycmd == 'rm' ]]; then
    if [[ "${args[0]}" == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || "${args[0]:0:6}" != 'cdn://' ]]; then
      word_wrap $(tput cols) 1:0-7 "usage: beluga-cli rm [-isr] <cdn://uri>" >&2
      if [[ "${args[0]}" == 'help' ]]; then
        word_wrap $(tput cols) 0 "deletes a file from the origin server." >&2
        word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
        exit 0
      elif [[ ${#args[@]} -lt 1 ]]; then
        word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
      elif [[ ${#args[@]} -gt 1 ]]; then
        word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
      elif [[ "${args[0]:0:6}" != 'cdn://' ]]; then
        word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
      fi
      exit 3
    fi

    remote="${args[0]#cdn:\/\/}"
    curroperation='mv'
    local='/dev/null'
    mode="down"
  else
    if [[ $inputflags =~ 'r' ]]; then
      word_wrap $(tput cols) 1 "unexpected option: -r" >&2
    fi

    curroperation=$primarycmd
    if [[ "${args[0]}" == 'help' || ${#args[@]} -gt 2 || ${#args[@]} -lt 2 || ( "${args[0]:0:6}" != 'cdn://' && "${args[1]:0:6}" != 'cdn://' ) ]]; then
      word_wrap $(tput cols) 1:0-7 "usage: beluga-cli $primarycmd [-is] <localpath> <cdn://uri> or <cdn://uri> <localpath> or <cdn://uri> <cdn://uri>" >&2
      if [[ "${args[0]}" == 'help' ]]; then
        if [[ $curroperation == 'mv' ]]; then
          word_wrap $(tput cols) 0 "moves a file to, from, or within the origin server: of the source and destination, one or both should be remote uris, formatted with cdn:// preceding the path." >&2
        else
          word_wrap $(tput cols) 0 "copies a file to, from, or within the origin server: of the source and destination, one or both should be remote uris, formatted with cdn:// preceding the path." >&2
        fi
        word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
        exit 0
      elif [[ ${#args[@]} -lt 2 ]]; then
        word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
      elif [[ ( "${args[0]:0:6}" != 'cdn://' && "${args[1]:0:6}" != 'cdn://' ) ]]; then
        word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
      elif [[ ${#args[@]} -gt 2 ]]; then
        word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
      fi
      exit 3
    fi


    if [[ "${args[0]:0:6}" == 'cdn://' && ${args[1]:0:6} == 'cdn://' ]]; then
      source=${args[0]#cdn:\/\/}
      destination=${args[1]#cdn:\/\/}
      mode="rename"
    else
      if [[ ${args[1]:0:6} == 'cdn://' ]]; then
        local=${args[0]}
        remote=${args[1]#cdn:\/\/}
        mode="up"
      elif [[ "${args[0]:0:6}" == 'cdn://' ]]; then
        local=${args[1]}
        remote=${args[0]#cdn:\/\/}
        mode="down"
      fi
    fi

    if [[ $local == '.' ]]; then
      local="$PWD"
    elif [[ ${local:0:2} == './' ]]; then
      local="$PWD/${local:2}"
    elif [[ ${local:0:3} == '../' ]]; then
      local="$PWD"
    elif [[ ${local:0:1} == '~' ]]; then
      local="${local/\~/$HOME}"
    fi
  fi

  if [[ $mode == "rename" ]]; then
    if [[ -z $source ]]; then
      msg="\033[31;1mfailed:\033[0m http://$cdnurl/ -> http://$cdnurl/${destination// /%20}"$'\n'"is a directory: http://$cdnurl/"
      display_message "$msg" >&2
      exit 1
    elif [[ ${source:$(expr ${#source} - 1)} == '/' ]]; then
      source=${source:0:$(expr ${#source} - 1)}
    fi

    curl -l "ftp://$serverdefault/$source/" > /dev/null 2> /dev/null
    result=$?

    if [[ $result -eq 0 ]]; then
      msg="\033[31;1mfailed:\033[0m http://$cdnurl/${source// /%20}/ -> http://$cdnurl/${destination// /%20}"$'\n'"is a directory: http://$cdnurl/${source// /%20}/"
      display_message "$msg" >&2
      exit 1
    else
      sourcefile=${source##*/}

      if [[ ${destination:$(expr ${#destination} - 1)} == '/' ]]; then
        destination+=$sourcefile
      else
        if [[ ! -z $destination ]]; then
          curl -l "ftp://$serverdefault/$destination/" > /dev/null 2> /dev/null
          result=$?
          if [[ $result -eq 0 ]]; then
            destination+="/$sourcefile"
          fi
        else
          destination+="/$sourcefile"
        fi
      fi

      if [[ $curroperation == 'mv' ]]; then
        msg="\033[1;92mmoving:\033[0m http://$cdnurl/${source// /%20} -> http://$cdnurl/${destination// /%20}"
        curl "ftp://$serverdefault/$source" -Q "-DELE $sourcefile" > "$HOME/.beluga-cli/.curltmp" 2> /dev/null
        result=$?
      elif [[ $curroperation == 'cp' ]]; then
        msg="\033[1;92mcopying:\033[0m http://$cdnurl/${source// /%20} -> http://$cdnurl/${destination// /%20}"
        curl "ftp://$serverdefault/$source" > "$HOME/.beluga-cli/.curltmp" 2> /dev/null
        result=$?
      fi

      display_message "$msg" >&2

      if [[ $result -eq 0 ]]; then
        if [[ $inputflags =~ "p" ]]; then
          curl -T "$HOME/.beluga-cli/.curltmp" "ftp://$serverdefault/$destination" --ftp-create-dirs 2> /dev/null
        else
          curl -T "$HOME/.beluga-cli/.curltmp" "ftp://$serverdefault/$destination" 2> /dev/null
        fi
        result=$?
        rm "$HOME/.beluga-cli/.curltmp"
      fi

      msg=$(validate_curl_result $result)
      curlstatus=$?

      display_message "$msg" >&2

      if [[ $curlstatus -eq 0 && $inputflags =~ 'i' ]]; then
        if [[ $curroperation == 'mv' ]]; then
          invalidate $source
          result1=$?

          invalidate $destination
          result2=$?

          if [[ $result1 -eq $result2 && $result1 -eq 0 ]]; then
            exit 0
          else
            exit 5
          fi
        else
          invalidate $destination
          result=$?
          (( result == 0 )) && exit 0 || exit 5
        fi
      else
        exit $curlstatus
      fi
    fi
  else
    if [[ ! -e $local && $mode == "up" ]]; then
      remotefile=${remote##*/}
      if [[ ! ( $remotefile =~ '.' || -z $remotefile ) ]]; then
        remote+='/'
      fi

      msg="\033[31;1mfailed:\033[0m $local -> http://$cdnurl/${remote// /%20}"$'\n'"does not exist: $local"
      display_message "$msg" >&2

      exit 1
    elif [[ -d $local && $mode == "up" ]]; then
      if [[ ${local:(-1)} == '/' ]]; then
        local=${local:0:$(expr ${#local} - 1)}
      fi

      remotefile=${remote##*/}
      if [[ ! ( $remotefile =~ '.' || -z $remotefile ) ]]; then
        remote="$remote/"
      fi

      msg="\033[31;1mfailed:\033[0m $local/ -> http://$cdnurl/${remote// /%20}"$'\n'"is a directory: $local/"

      display_message "$msg" >&2
      exit 1
    fi

    if [[ ! -z $remote ]]; then
      remoteendchar=${remote:$(expr ${#remote} - 1)}

      if [[ $remoteendchar == '/' ]]; then
        remote=${remote:0:$(expr ${#remote} - 1)}
      fi

      dircontents=$(curl -l "ftp://$serverdefault/$remote/" 2> /dev/null)
      result=$?

      if [[ $result -eq 0 ]]; then # if $remote is a directory...
        if [[ $mode == "down" ]]; then
          if [[ $primarycmd == 'rm' ]]; then
            if [[ $inputflags =~ 'r' ]]; then
              msg="\033[1;92mdeleting:\033[0m http://$cdnurl/${remote// /%20}/"
              display_message "$msg"

              recursive_delete $remote
              result=$?

              if [[ $result -eq 0 ]]; then
                msg="\033[1;92mdone\033[0m"
              elif [[ $result -eq 5 ]]; then
                msg="\033[1;33mpartly \033[1;33mfailed:\033[0m some files not deleted"
              else
                msg="\033[31;1mfailed:\033[0m http://$cdnurl/${remote// /%20}/ not deleted"
              fi
            elif [[ -z "$dircontents" ]]; then
              msg="\033[1;92mdeleting:\033[0m http://$cdnurl/${remote// /%20}/"
              display_message "$msg"
              curl -l "ftp://$serverdefault/" -Q "-RMD $remote" > /dev/null 2> /dev/null
              result=$?
              validationresult=$(validate_curl_result $result)
              result=$?
              word_wrap $(tput cols) 0  "$validationresult" >&2
              exit $result
            else
              msg="\033[1;92mdeleting:\033[0m http://$cdnurl/${remote// /%20}/"
              display_message "$msg" >&2
              msg="\033[31;1mfailed:\033[0m operation not completed [directory not empty]"
              result=1
            fi
          else
            msg="\033[31;1mfailed:\033[0m http://$cdnurl/${remote// /%20}/ -> $local"$'\n'"is a directory: http://$cdnurl/${remote// /%20}/"
            result=1
          fi

          display_message "$msg" >&2

          exit $result # and we are downloading (or deleting)
        elif [[ $mode == "up" ]]; then
          remote+="/${local##*/}"
        fi
      else # if $remote is not a directory
        if [[ $mode == "up" ]]; then # if uploading
          if [[ $remoteendchar == '/' ]]; then # and the user ended the remote uri with a /
            remote+="/${local##*/}" # add the local filename to $remote
          else # if the user didn't end it with a /
            remotefile=${remote##*/}
            localfile=${local##*/}
            if [[ ( ! $remotefile =~ '.' ) && $localfile =~ '.' ]]; then
              # if the local filename has an extension and the remote doesn't,
              # assume it was intended to be a directory
              remote+="/$localfile"
            fi
          fi
        elif [[ $mode == "down" ]]; then # if downloading
          if [[ $remoteendchar == '/' ]]; then
            # if the user included a / where there shouldn't be one,
            # tell them the verbatim file doesn't exist (even if it otherwise might)
            msg="\033[31;1mfailed:\033[0m http://$cdnurl/${remote// /%20}/ -> $local"$'\n'"does not exist: $remote/"
            display_message "$msg" >&2
            exit 1
          fi
        fi
      fi
    else
      if [[ $mode == "up" ]]; then
        remote=${local##*/}
      elif [[ $mode == "down" ]]; then
        if [[ $primarycmd == 'rm' ]]; then
          msg="\033[31;1mfailed:\033[0m deleting http://$cdnurl/"$'\n'"is a directory: http://$cdnurl/"
        else
          msg="\033[31;1mfailed:\033[0m http://$cdnurl/ -> $local"$'\n'"is a directory: http://$cdnurl/"
        fi
        display_message "$msg" >&2
        exit 1
      fi
    fi

    if [[ $mode == "up" ]]; then
      if [[ $curroperation == "cp" ]]; then
        msg="\033[1;92muploading:\033[0m $local -> http://$cdnurl/${remote// /%20}"
        if [[ $inputflags =~ "p" ]]; then
          curl -T "$local" "ftp://$serverdefault/$remote" --ftp-create-dirs 2> /dev/null
        else
          curl -T "$local" "ftp://$serverdefault/$remote" 2> /dev/null
        fi
        result=$?
      elif [[ $curroperation == "mv" ]]; then
        msg="\033[1;92mmoving:\033[0m $local -> http://$cdnurl/${remote// /%20}"
        if [[ $inputflags =~ "p" ]]; then
          curl -T "$local" "ftp://$serverdefault/$remote" --ftp-create-dirs 2> /dev/null
        else
          curl -T "$local" "ftp://$serverdefault/$remote" 2> /dev/null
        fi
        result=$?
        if [[ $result -eq 0 ]]; then
          rm $local
          result=$?
        fi
      fi
    elif [[ $mode == "down" ]]; then
      remotefile=${remote##*/}

      if [[ ${local:(-1)} != '/' ]]; then # if the local path doesn't end with a /...
        if [[ -d "$local" ]]; then
          # if $local refers to an existing directory nevertheless,
          # the filename should be the same as the remote filename
          local+="/$remotefile"
        elif [[ $local != '/dev/null' ]]; then
          localfile=${local##*/}

          if [[ ( ! $localfile =~ '.' ) && $remotefile =~ '.' ]]; then
            # if the localfile has no extension but the remote
            # file does, assume it is meant to refer to a directory
            if [[ ! ( -d "$local" ) ]]; then
              # if the directory doesn't exist, create it
              if [[ $inputflags =~ "p" ]]; then
                mkdir -p "$local"
              else
                msg="\033[31;1mfailed:\033[0m http://$cdnurl/${remote// /%20} -> $local"$'\n'"no such directory: $local"
                display_message "$msg" >&2
                exit 1
              fi
            fi
            # the local filename should be the same as the remote
            local+="/$remotefile"
          else
            if [[ ! ( "${local%/*}" == $local || -d "${local%/*}" ) ]]; then
              # if the local path without the filename doesn't exist, and the
              # path is not simply the filename (which is the case when downloading
              # into the current folder and referring to the destinations by
              # filename alone, create it.
              if [[ $inputflags =~ "p" ]]; then
                mkdir -p "${local%/*}"
              else
                msg="\033[31;1mfailed:\033[0m http://$cdnurl/${remote// /%20} -> $local"$'\n'"no such directory: ${local%/*}"
                display_message "$msg" >&2
                exit 1
              fi
            fi
          fi
        fi
      else # if the local path does end with /
        if [[ ! -d "$local" ]]; then # create the directory if it didn't already exist
          if [[ $inputflags =~ "p" ]]; then
            mkdir -p "$local"
          else
            msg="\033[31;1mfailed:\033[0m http://$cdnurl/${remote// /%20} -> $local"$'\n'"no such directory: $local"
            display_message "$msg" >&2
            exit 1
          fi
        fi

        local+="$remotefile"
      fi

      if [[ $curroperation == "cp" ]]; then
        msg="\033[1;92mdownloading:\033[0m http://$cdnurl/${remote// /%20} -> $local"
        curl "ftp://$serverdefault/$remote" -o "$local" 2> /dev/null
        result=$?
      elif [[ $curroperation == "mv" ]]; then
        if [[ $primarycmd == 'rm' ]]; then
          msg="\033[1;92mdeleting:\033[0m http://$cdnurl/${remote// /%20}"
        else
          msg="\033[1;92mmoving:\033[0m http://$cdnurl/${remote// /%20} -> $local"
        fi
        curl "ftp://$serverdefault/$remote" -Q "-DELE $remotefile" -o "$local" 2> /dev/null
        result=$?
      fi
    fi
  fi

  display_message "$msg" >&2

  validationresult=$(validate_curl_result $result)
  result=$?

  word_wrap $(tput cols) 0  "$validationresult" >&2

  if [[ $result -eq 0 ]]; then
    if [[ ( $mode == "up" || $primarycmd == "rm" ) && $inputflags =~ 'i' ]]; then
      invalidate $remote
      result=$?
    fi
  fi
  exit $result
elif [[ $primarycmd == 'mkdir' ]]; then
  if [[ ${#inputflags} -gt 0 ]]; then
    illegalflags=${inputflags//"s"}
    illegalflags=${illegalflags//"p"}
    if [[ ${#illegalflags} -gt 0 ]]; then
      word_wrap $(tput cols) 1 "unexpected options: -$illegalflags" >&2
    fi
  fi

  if [[ "${args[0]}" == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || "${args[0]:0:6}" != 'cdn://' ]]; then
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli $primarycmd [-s] <cdn://uri>" >&2
    if [[ "${args[0]}" == 'help' ]]; then
      word_wrap $(tput cols) 0 "creates a new directory on the origin server." >&2
      word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    elif [[ ${#args[@]} -lt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
    elif [[ ${#args[@]} -gt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
    elif [[ "${args[0]:0:6}" != 'cdn://' ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
    fi
    exit 3
  else
    destination="${args[0]:6}"

    display_message "\033[1;92mcreating \033[1;92mdirectory:\033[0m http://$cdnurl/${destination// /%20}" >&2

    if [[ ${destination:$(expr ${#destination} - 1)} == "/" ]]; then
      destination=${destination:0:$(expr ${#destination} - 1)}
    fi

    curl "ftp://$serverdefault/$destination/" > /dev/null 2> /dev/null
    result=$?

    if [[ $result -eq 0 ]]; then
      msg="\033[31;1mfailed:\033[0m operation not completed [dir already exists]"
      word_wrap $(tput cols) 0 $msg >&2
    else
      if [[ $inputflags =~ "p" ]]; then
        serverbase="${serverdefault%%/*}"
        if [[ $serverbase != $serverdefault ]]; then
          curl "ftp://$serverbase/" -Q "SITE mkdir /${serverdefault#*\/}/$destination/" > /dev/null 2> /dev/null
          result=$?
        else
          curl "ftp://$serverbase/" -Q "SITE mkdir /$destination/" > /dev/null 2> /dev/null
          result=$?
        fi

        if [[ $result -ne 0 ]]; then
          alreadyexists=''
          tocreate=''

          if [[ "${destination%/*}" == $destination || $destination == ${destination##*/} ]]; then
            tocreate=$destination
          else
            if [[ $(curl "ftp://$serverdefault/${destination%%/*}/" > /dev/null 2> /dev/null) -eq 0 ]]; then
              alreadyexists+="${destination%%/*}"
              tocreate="${destination#*\/}"

              while [[ $tocreate != "${tocreate#*\/}" ]]; do
                curl "ftp://$serverdefault/$alreadyexists/${tocreate%%/*}/" > /dev/null 2> /dev/null
                result=$?

                if [[ $result -eq 0 ]]; then
                  alreadyexists+="/${tocreate%%/*}"
                  tocreate=${tocreate#*\/}
                else
                  break
                fi
              done
            else
              tocreate=$destination
            fi
          fi

          IFS='/'
          counter=0
          for folder in $tocreate; do
            curl "ftp://$serverdefault/$alreadyexists/" > /dev/null 2> /dev/null
            result=$?

            if [[ $result -eq 0 ]]; then
              alreadyexists="$alreadyexists/$folder"
              curl "ftp://$serverdefault/" -Q "-MKD $alreadyexists" > /dev/null 2> /dev/null
              result=$?
              if [[ $result -ne 0 ]]; then
                if [[ $counter -gt 0 ]]; then
                  display_message "\033[1;33mfailed:\033[0m could not create http://$cdnurl/$alreadyexists/" >&2
                  exit 5
                else
                  word_wrap $(tput cols) 0 $(validate_curl_result $result) >&2
                  exit 1
                fi
              else
                let counter=counter++
              fi
            else
              word_wrap $(tput cols) 0 $(validate_curl_result $result) >&2
              exit 5
            fi
          done
        fi

        word_wrap $(tput cols) 0 "\033[1;92mdone\033[0m" >&2
        exit 0
      else
        curl "ftp://$serverdefault/" -Q "-MKD $destination" > /dev/null 2> /dev/null
        result=$?

        validationresult=$(validate_curl_result $result)
        result=$?

        word_wrap $(tput cols) 0 $validationresult >&2
        exit $result
      fi
    fi
  fi
elif [[ $primarycmd == 'iv' ]]; then
  if [[ $inputflags =~ 'i' || $inputflags =~ 'r' ]]; then
    if [[ $(echo $inputflags | tr -dc 'ir' | awk '{print length}') -gt 1 ]]; then
      word_wrap $(tput cols) 1 "unexpected options: -$(echo $inputflags | tr -dc 'ir')" >&2
    else
      word_wrap $(tput cols) 1 "unexpected option: -$(echo $inputflags | tr -dc 'ir')" >&2
    fi
  fi

  if [[ "${args[0]}" == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || "${args[0]:0:6}" != 'cdn://' ]]; then
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli $primarycmd [-s] <cdn://uri>" >&2
    if [[ "${args[0]}" == 'help' ]]; then
      word_wrap $(tput cols) 0 "invalidates a file so it must be retrieved again from the origin server." >&2
      word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    elif [[ ${#args[@]} -lt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
    elif [[ ${#args[@]} -gt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
    elif [[ "${args[0]:0:6}" != 'cdn://' ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
    fi
    exit 3
  else
    destinationpath=${args[0]#cdn:\/\/}

    invalidate $destinationpath
  fi
elif [[ $primarycmd == 'ls' || $primarycmd == 'll' ]]; then
  if [[ ! -z ${inputflags//s} ]]; then
    invalidflags=${inputflags//s}
    if [[ ${#invalidflags} -gt 1 ]]; then
      msg="unexpected options: -$invalidflags"
    elif [[ ${#invalidflags} -gt 0 ]]; then
      msg="unexpected option: -$invalidflags"
    fi

    word_wrap $(tput cols) 0 "$msg" >&2
  fi


  if [[ "${args[0]}" == 'help' || ${#args[@]} -gt 1 || ${#args[@]} -lt 1 || "${args[0]:0:6}" != 'cdn://' ]]; then
    word_wrap $(tput cols) 1:0-7 "usage: beluga-cli $primarycmd [-s] <cdn://uri>" >&2
    if [[ "${args[0]}" == 'help' ]]; then
      word_wrap $(tput cols) 0 "retrieves and lists the contents of a specified directory on the origin." >&2
      word_wrap $(tput cols) 0 "for more detailed help, run \033[1mbeluga-cli \033[1mhelp\033[0m." >&2
    elif [[ ${#args[@]} -lt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too few args" >&2
    elif [[ ${#args[@]} -gt 1 ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes too many args" >&2
    elif [[ "${args[0]:0:6}" != 'cdn://' ]]; then
      word_wrap $(tput cols) 0 "\033[31;1millegal input:\033[0m input [beluga-cli $@] includes no cdn:// uri" >&2
    fi
    exit 3
  fi

  remote=${args[0]#cdn:\/\/}

  endchar=${remote:(-1)}

  if [[ $endchar != '/' && ! -z $remote ]]; then
    remote+='/'
  fi

  myurl=http://$cdnurl/${remote// /%20}

  msg="\033[1;92mlisting contents of\033[0m $myurl"

  display_message "$msg" >&2

  if [[ $primarycmd == 'ls' ]]; then
    listing=$(curl -l "ftp://$serverdefault/$remote" 2> /dev/null)
    result=$?
  elif [[ $primarycmd == 'll' ]]; then
    listing=$(curl "ftp://$serverdefault/$remote" 2> /dev/null)
    result=$?
  fi

  validationresult=$(validate_curl_result $result)
  exitstatus=$?

  if [[ $exitstatus -eq 0 ]]; then
    if [[ ! $inputflags =~ 's' ]]; then echo -e "\033[1;92msuccess\033[0m" >&2; fi
    echo -e "$listing"
  else
    word_wrap $(tput cols) 0  "$validationresult" >&2
  fi
fi
